#' @title Internal function store_drake_config
#' @description Do the preparatory work
#' for \code{\link{make}()} with a distributed computing
#' backend (see the \code{parallelism} argument).
#' @export
#' @keywords internal
#' @param config Internal configuration list from
#' \code{\link{drake_config}()}.
#' @return Nothing.
#' @examples
#' \dontrun{
#' test_with_dir("Quarantine side effects.", {
#' load_basic_example()
#' config <- drake_config(my_plan)
#' prepare_distributed(config = config)
#' })
#' }
prepare_distributed <- function(config){
  this_cache_path <- cache_path(config$cache)
  if (identical(globalenv(), config$envir)){
    save(
      list = ls(config$envir, all.names = TRUE),
      envir = config$envir,
      file = globalenv_file(this_cache_path)
    )
  }
  config$cache$set(key = "envir", value = config$envir, namespace = "config")
  invisible()
}

finish_distributed <- function(config){
  dir <- cache_path(config$cache)
  file <- globalenv_file(dir)
  unlink(file, force = TRUE)
}

#' @title Internal function build_distributed
#' @description Build a target for a distributed parallel
#' backend such as "Makefile" or "future".
#' @details This function is not meant to be called by the user.
#' It is only exposed so that \code{future::future()} works
#' as expected for \code{"future"} parallelism.
#' @export
#' @keywords internal
#' @param target name of the tartet to build
#' @param meta_list list of hash metadata
#' output from \code{meta_list()}.
#' @param config Internal configuration list from
#' \code{\link{drake_config}()}.
#' @return Nothing.
#' @examples
#' # This is not actually a user-side function.
#' # See the body of mk() to see how build_distributed
#' # is used in "Makefile" parallelism.
build_distributed <- function(target, meta_list, cache_path){
  config <- recover_drake_config(cache_path = cache_path)
  do_prework(config = config, verbose_packages = FALSE)
  prune_envir(targets = target, config = config)
  if (is.null(meta_list)){
    meta_list <- meta_list(targets = target, config = config, store = TRUE)
    do_build <- should_build_target(
      target = target,
      meta = meta_list[[target]],
      config = config
    )
    if (!do_build){
      return(invisible())
    }
  }
  drake_build(
    target = target,
    meta = meta_list[[target]],
    config = config
  )
  invisible()
}

recover_drake_config <- function(cache_path){
  cache <- this_cache(cache_path, verbose = FALSE)
  config <- read_drake_config(cache = cache)
  if (identical(globalenv(), config$envir)){
    dir <- cache_path(cache = cache)
    file <- globalenv_file(dir)
    load(file = file, envir = config$envir)
  }
  config
}
